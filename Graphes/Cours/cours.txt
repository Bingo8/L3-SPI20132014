----Graphes-----
Made In Switzerland
Libre à tous de faire une belle version pdf!!
Cours du 22/10/2013


________________________
2.2 Limites d'efficacité
------------------------

(1)Seuil de Sasa..... /Version sans tas
(2)Initialisation du tas?

->initialiser une fois pour toute, complètement
->initialiser petit à petit, en ajoutant les éléments au fur et à mesure

La première version n'est pas idéale, l'autre étant plus efficace jusqu'a 30%

constante cachée :  f(n) = a n² +bn + alog(n)
    ->a est la constante cachée.
_____________
3 Distanciers
-------------
3.1 Pb
-------

G(S, H)
-On veut calculer les chemins les + courts de sommets à sommets.

-Circuits? acceptés? (attention aux circuits négatifs ou positifs)
                        >0   A-(2)->B-(3)->C-(4)->A
                        
                        <0  A-(2)->B-(3)->C-(-10)->A
_________________
3.2 Algo de Floyd
-----------------
-Pas de circuits négatifs
-principe : x° de matrice

Soit trois Sommets I, J et K. On cherche à verifier quel est le chemin le plus court de I à J

    rep pr K de 1 à S
        rep pour I de 1 à S
            rep pour J de 1 à S
                si d(I, J) > d(I, K) + d (K, J)         //Si la distance directe [IJ] est plus grande que [IK]+[KJ]



     -> A > B (avec A ~= d(I, J) et B ~= d(I, K)+d(K, J)
        ->si B a un infini, ne rien faire

        Sinon si A infini, Actualiser d(I, J)
            sinon actualise d(I, J) si c'est mieux

Complexité en O(S³)
_____________________________
4 Variantes sur les distances
-----------------------------
4.1 Chemin le + long
--------------------
(figure n)

Algo possible si
-pas de circuits
-graphe orienté

Comment fais-t'on ?
On remplace chaque distance par son opposé, puis Dijkstra, puis complémenter les résultats

*****Remarque*****
La detection de circuit est exécutée avant (dans le cas général, s'il s'agit d'un graphe que vous ne connaissez pas)

______________________
4.2 Chemin le + fiable
----------------------

cyndinique = études des risque matériels.

On attache à chaque arc ou arrête un pourcentage de risque, ou une fiabilité /!\ la fiabilité est l'inverse du risque

ex : A - 50% -> B - 25% -> C
Il faut calculer le produit des fiabilité (des pourcentages)

A - alpha -> B - Beta -> C

1°)alpha = log(50%)
Beta = log(25%)
En prenant le log, on est ramené à des additions. Car log(x) + log(y) = log(xy)

2°)=>Dijkstra, normal avec addition

3°)On réduit les résultats en passant aux exponentielles (puissance de 2)

ex : Graphe G
A - 8 -> B - 4 -> C - 8 -> D

Graphe G'
A'- 3 -> B'- 2 -> C'- 3 -> D'

Dijkstra -> d(A', D') = 8
ce qui donne 2⁸ = 256
Bizarre, mais le passage au log était plus facile

____________________________
4.3 Chemins moyen le + court
----------------------------

soit A - 2 ->B - 4 ->C - 3 ->D

On cherche la distance la plus courte moyennée
Ainsi, de A à B, c'est 2. De A en C, on a 6/2 = 3. de A en D, on a 9/3 = 3

______________________
5 Composantes connexes
----------------------
5.1 Connexité "faible"
---------------------

Définition : un grapheG=(S, A)  est connexe s'il existe toujours au moins un chemin entre deux sommets quelconques de G (non-orienté ou transformé en non-orienté, c'est à dire qu'on se fiche des flèches)

ainsi, A -> B <- C est un graphe connexe.

l'algo utilise ici un parcours en profondeur d'abord. Il faut une exploration.

-Pb général : Attribuer à chaque sommet le n° de sa composante connexe.

CC[]<-0    ##N° de composante connexe attaché à chaque sommet
nCC <-0
rep
    X<- Unsommet tel que CC[X] = 0      ##X un sommet quelconque non marqué
    nCC++
    CC[x]<-nCC
    Explorer G depuis X
        pour tout Y rencontré
            faire CC[Y]=nCC
fin rep

___________________
5.2 Connexité forte
-------------------

Il est indispensable qu'il s'agisse d'un Graphe orienté
Définition : Un graphe est fortement connexe s'il existe pour toute paire de (X, Y) de sommet 1 chemin de X à Y et vice versa (de Y à X).

Algo (simple mais lent, on sait faire mieux)

CFC[]<- O
nCFC<- 0
rep
    X<- 1 Sommet tel que CFC[X] = 0
    nCFC ++
    explorer dans G depuis X (memoriser les sommets rencontrés);
    explorer dans H depuis X |  ## H est le graphe inverse de G-> on inverse le sens des flèches
                             ->(mémoriser les sommets rencontrés)
    effectuer CFC[Y]<- nCFC si Y a été mémorisé dans G et dans H
finrep

___________________
6 Graphes biparties
-------------------
6.1 Pb
------

On veut savoir si un graphe est biparti

Un graphe est biparti s'il est 2-colorable-> On colorie chaque sommet, et chaque sommet ne doit pas être de la même couleur que ses voisis (sommets adjacents)
Un graphe est biparti si et seulement s'il ne comporte aucun cycle impair

________
6.2 Algo
--------
________________
7 Ordonnencement
----------------
7.1 Vocabulaire
---------------

Les Arcs du graphe correspondent à des tâches
Les Ommets sont des états

ex: D - 15j -> F   Il faut 15 jours à partir du Début pour terminer les Fondations

Date au plus tot/tard -> Marge : chemin critique

Ainsi A - 2j -> B
      A - 1j -> C
      C - 4j -> B

La date au plus tot est de cinq jours  : C'est le chemin le plus long depuis le départ.
La date au plus tard est le chemin le plus long depuis l'arrivée retranché au temps total.
Le chemin critique est le chemin sur lequel une augmentation du temps rallogerait la durée totale

________
7.2 Algo
--------

On introduit deux sommets, Départ et Arrivée dans G.
On relie tous les sommets sans prédecesseur à D avec une durée nulle, et tous les sommets sans Successeurs à A avec une durée nulle.
On chemine en mode chemin le + long dans G(comme vu précedemment).
On obtien Dtot(X) La date au + tot de A qui donne la durée des travaux.
On chemine dans le graphe inverse de G. SDtard est la durée obtenue depuis A.
La date au plus tard d'accomplissement des tous les travaux pour valider X est Dtot(A) - Dtard(A)

La marge critique de chaque sommet est la différence entre la date au plus tot et la date au plus tard

le(s) chemin(s) critique(s) est le chemin qui passe par tous les sommets de marge nulle.







___________________________________________________________________________________________
Cours du 05/11/2013
__________________
Flots et couplages
------------------

Intro :
ça permet d'optimiser les choses.

1 Flots
1.1 Définition
G est valué par des capacités
    -maximale Cij  i -- > ---j   (considéré comme facile)
    -minimale                    (considéré comme difficile)
}polynomiale

    -encadrement min/max

    -idem avec coût d'utilisation à chaque arc

-Source : 5 -- 1 -->_-- 2 -->_      (sink)
           \-- 3 -->_ -- 2 /
-Puit (trap)

capacité résiduelle : capacité max d'un arc, moins ce qui a été consommé précedemment.

1.2 trsformat° des graphes

*contrainte intermédiaire*

(S) -- 4--> (A.3) -- 7 --> (B) --2 --> (T)
S = source, T = trap (puits).

A possède une contrainte limitant le débit à 3.
Si l'on rajoute un sommet entre A et A et un arc entre A et T, on peut modéliser A en deux sommets : une entrée et une sortie, avec une capacité de 3 entre les deux.

*Arête -> arc :
A --- B == A -->-- B
             \-<-/

1.3 Exemple : 


-> ce qu'il faut retenir : les flots s'ajoutent algèbriquement.


1.4 Algo de Flots max et cap max
(note :C() capacité,  Cr()capacité résiduelle et o⁺ flux)


F = 0 (flot max)
rep jsq impossibilité (c = 0)
    c <- chaîne améliorante
    si c > 0
        o⁺ = in | des capac résiduelles sur la chaîne
        pour chaque arc ij  sur la chaîne
        Cr(ij) = Cr(ij) - o⁺ si pris ds le sens de l'arc
        ou Cr(ij) = Cr(ij) + o⁺ si pris ds l'autre sens.
    fs
frep

chaîne améliorante = chemin de S à T tel que pour chaque arc ij, 
Cr(ij) > 0 ds le sens normal 
ou 
C(ij)-Cr(ij)  > 0 ds le sens inverse

Utiliser la recherche d'un plus court chemin(ex Dijkstra)

1.5 Max Flow = Min Cut

L'algo donne un flot optimum qui est le flot max.
Justificat° : considérer les coupes

1.6 Complexité algorithmique

Chemin le plus court : O(S³) avec Dijkstra standard et graphe dense
=> contribution de 1 ds le pire cas
=> itération au pire de "capamax" fois.
=>O(S³ . "capamax")


___________
2 Couplages
-----------
Un couplage est un appareillement de sommets
On cherche un nombre maximal de couples <=> un couplage maximal <=> 1 couplage de cardinal maximal




_____________________________________________________________
                   Les grammaires
                   --------------
______________
1 définitions :
--------------
1.1 Alphabet et mot:
*Un alphabet est un ensemble de lettre minuscule (sans accents). ensemble fini.
*A = {a, b}
*un mot est une suite ordonnée de lettres de l'alphabet éventuellement vide. 
m1 = ab   |m1| = 2
m2 = ba
m3 = a⁵b = aaaaab  |m3| = 6

/!\ mot vide noté 1, |1|= 0

a.1.1.b.1.a.1 = aba
|a.1.1.b.1.A.1| = 3

____________
1.2 Facteurs
------------

1 facteur = 1 partie de mot (éventuellement vide) = 1 sous chaine (prélèvement ds le mot d'une série de lettre consécutive)

ex : m1 = a³ba  alors a²b est un facteur de m1
un facteur gauche  ex a² est un facteur gauche de m1
"        " droit
"        " strict  est un facteur non vide

ex : 
m2 = a²b     =aab
m3 = ab²     =abb
m4 = a²b⁵ab² =aabbbbbabb

m2 est un facteur gauche de m4 et m3 est un facteur droit de m4.


****************************************************************
cours du 15/11/2013

_____________________
1.3 Opérateurs * et +
---------------------

alphabet A = {a, b}
opérateur * :
A* = {1} U A U A² U A² U .....
   = {a+b} si A = {a, b}



. -> opérande de concaténation => ab == a.b
A.A == (a+b).(a+b) = a.a +a.b + b.a + b.b = a² + ab +b²

E = {1, a, a², ad²}
E* =

Opérateur + :
A+ = A U A² U A³ U....

E = {1, a, a²}
E+ = E (1 + a +a²) + E²(1 +a + a² + a³ + a⁴) +....

_____________
2 Vocabulaire
-------------

2.1 Définition

*Ensemble de majuscules, réservé aux ensembles de mots
ex : S = {a, a², ba⁵}
1 seule majuscule

________________________________________
2.2 Opérations sur les ensembles de mots
----------------------------------------

\0 -> représente un ensemble vide (ce n'est pas le mot vide!!!!!!!!!!!!!!!!)

ex : a²b.1 = a²b

E = {a, a²b, ab² }
F = {b³, b⁵}

U = E + E.F + E.\0.F + \0.\O
= {a, a²b, ab², ab³, ab⁵, a²bb³, a²bb⁵, ab²b³, ab²b⁵}

____________
3 Grammaires
---------------
3.1 Définitions

Grammaires : ensemble de règles/productions

<V, A, P, ...> au minimum
Vocabulaire
Alphabet
Productions ou règles

ex : 
     S -> ab
     S -> T {b, abab}
     T -> aU
     U -> abT
     U -> b
Ce sont des productions

S = {ab, abab}

      S
     /  \
    ab   T
      /   \
     a     U
         /   \
        U2    U1
       /  \   |
      ab   T  b

U -> abT + b
U -> aba.u + ab
     (aba)*. ab

production au sens strict : S -> m  avec m appartient à A*
                              1 seul terme, 1 règle

production au sens large S ->m1 + m2

_________________________
3.2 Classes de grammaires
-------------------------

*classe de langage
(((((Expressions régulière) Automate à pile) Grammaire Algébrique)sensible au contexte)Problèmes récursifs)
                                                                                                    ^
                                                                                                    |
                                                                                        limite pour les ordinateurs
Nous allons oublier les problèmes récursifs et les langages sensibles au contexte

*Classes de Grammaires

1)Grammaires linéaires, régulières, rationnelles, reconnaissable (c'est la même chose)
     S    ------------>         aU
     S    ------------>         1
  (1terme à gauche)

2)Grammaires algébriques(Context Free Grammar)
1 terme à gauche, qui est toujours une majuscule, et a droite, une collection de majuscule et/ou de minuscule
S ->aUbV

règle algébrique de la forme : (A : Alphabet et V : Vocabulaire, g terme gauche et td terme droit)
tg -> td  avec tg € à V
               td € à (A U V)*
Une grammaire algébrique reconnait les expressions correctement parenthèsés.

3)Grammaire sensibles au contexte (Context Sensitive Grammar)
le terme a gauche € (a U V)*V(a U V)* -> au moins une majuscule à gauche

4)grammaires récursives
le terme gauche est non vide
     ex :S -> aT + bU
          atU ->b aSSb + c
          acbb -> ab² -> FAUX

____________
3.3 Exemple
------------

S -> aT + bU
T -> abT +1
U -> aUb + a



________________________________________________________________________________________________
Cours du 22/11/2013

____________________
Grammaires Linéaires
--------------------
1 Définitions et propriétés
****************************
1.1 Linéaire à droite

Soit une grammaire Gd = <V, A, P>
Vocabulaire (majuscules)
Alphabet (minuscules)
Productions réduites à soit P ->aT
                       soit P ->1

Un mot est reconnu, si, partant de S(état initial), on atteint un état final (que des minuscules dans le mot).

L(G) = {m € A*, S -*->m}           =>Langage de G
A = {a, b}                         =>Alphabet
A* = {1, a, b, aa, ab, a³, ......}

S - - - > m
_____________________
1.2 Linéaire à gauche
S -> Tb
S -> 1
(la majuscule est à gauche, contrairement au paragraphe d'au dessus)
_________________
1.3 Lien avec AEF

AEF = 1 graphe
     1 sommet = 1 état de l'AEF
     chaque arc représente 1 transistion entre 2 états, franchie si la lettre attaché à l'arc est reconnue
-> Automate d'Etat Fini

S -a-> T -b-> U
S -> aT
T -> bU
U -> 1
_____
2 AEF
-----
2.1 Définitions

Un AEF <=> Â =< A, E, I, F, T>
Alphabet
Etat = corresponds à un sommet dans le graphe
etats Initiaux (I€E)
etats Finaux
Transition -> arc dans 1 graphe
     Une transition, c'est un triplet (alpha, l, w)
     alpha = etat de départ
     l = lettre sur l'arc issus de T
     w = etat d'arrivée

ex (précédent)
     A = {a, b,}
     E = {S, T, U}
     I = {S}
     F = {U}
     T = {(S, a, T), (T, b, U)}
Un mot est reconnu ssi il existe un etat initial i et un etat final f et une suite de transitions delta tel que:
delta(i, m) = f=> m est reconnu

/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\
J'utilise la lettre Â au lieu d'un A majuscule anglais (script)
\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/\¡/

*Un automate complet : Âc:
Pour tout état e et toute lettre l de A, il existe une transistion delta(e, l)

Ainsi, pour l'exemple précédent
S -a-> T -b-> U
on complète chaque état pour chaque lettre
S -a-> T -b-> U =>
 \     |     /
  b    a    a,b
   \   |   /
    v  v  v
     ( þ )
     |   ^
     -a,b|

*Automate déterministe Âd
Il existe un seul etat initial et pour tout état e et tout lettre l, il existe une seule transition au plus(pas plus de une)
______________
2.1 Complétude

méthode :
1)Ajouter 1 trappe : etat(þ) bottom 
/!\/!\/!\/!\/!\ j'utilise þ ici au lieu d'un T à l'envers
2)en faire une trappe  flèche sur lui même avec A  ->   (þ)
3)pour tout etat e, si une lettre l ne part pas de e, ajouter la transisition (e, l, þ)
___________________
2.3 Déterminisation

1) Tabuler l'AEF Âd
2) Générer les super états
3) Déduire l'AEF Âd

1°           a      b
     ->S||   U   || /
     ->T||   V   || W
     <=U||   /   || W
       V||  U V  || /
     <=W||   W   || /

2°           a       b
{S, T}  || {U,V} || {W}
{U, V}  || {U,V} || {W}
{W}     ||  {W}  || /

3°(je fais pas les dessins)
(en tout cas, pas les trop compliqués)

